# -*- coding: utf-8 -*-
"""json.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DmzozWyIr7WSv_nx8oDJD9p0c-SBB3kX
"""

import json
import re

def clean_image_url(raw_url):
    """
    Cleans the raw image URL to get the direct beminimalist.co CDN link.
    """
    prefix_to_find = 'https://beminimalist.co/cdn/shop/'
    if prefix_to_find in raw_url:
        start_index = raw_url.find(prefix_to_find)
        url_part = raw_url[start_index:]
        url_part = re.sub(r'&width=\d+', '', url_part)
        url_part = re.sub(r'&height=\d+', '', url_part) # Also remove height
        url_part = re.sub(r'&crop=.*?(&|$)', r'\1', url_part) # Also remove crop
        return url_part.strip('?')
    # Fallback for URLs not matching the full CDN structure, remove common query params
    url_part = re.sub(r'&width=\d+', '', raw_url)
    url_part = re.sub(r'&height=\d+', '', url_part)
    url_part = re.sub(r'&crop=.*?(&|$)', r'\1', url_part)
    return url_part.strip('?')


def infer_category(name):
    name_lower = name.lower()
    if "cleanser" in name_lower: return "Cleanser"
    if "face wash" in name_lower: return "Face Wash" # Often used synonymously with cleanser
    if "sunscreen stick" in name_lower : return "Sunscreen Stick"
    if "sunscreen" in name_lower or "spf" in name_lower: return "Sunscreen"
    if "hair serum" in name_lower or ("hair growth" in name_lower and "serum" in name_lower): return "Hair Serum"
    if "serum" in name_lower: return "Serum" # Make sure this is after hair serum
    if "moisturizer" in name_lower or "moisturiser" in name_lower: return "Moisturizer"
    if "toner" in name_lower: return "Toner"
    if "peel" in name_lower: return "Peel"
    if "body lotion" in name_lower: return "Body Lotion"
    if "lotion" in name_lower: return "Lotion" # Generic lotion if not body
    if "lip treatment balm" in name_lower or "lip balm" in name_lower: return "Lip Balm"
    if "eye cream" in name_lower: return "Eye Cream"
    if "face cream" in name_lower: return "Face Cream" # More specific than generic cream
    if "cream" in name_lower: return "Cream" # Generic cream
    if "exfoliator" in name_lower or "exfoliating liquid" in name_lower: return "Exfoliator"
    if "shampoo" in name_lower: return "Shampoo"
    if "conditioner" in name_lower: return "Hair Conditioner"
    if "hair mask" in name_lower: return "Hair Mask"
    if "hair oil" in name_lower: return "Hair Oil"
    if "body wash" in name_lower: return "Body Wash"
    if "underarm roll-on" in name_lower or "underarm" in name_lower: return "Underarm Care"
    if "kit" in name_lower: return "Kit"
    if "pimple patch" in name_lower or "acne patch" in name_lower: return "Acne Patch"
    return "Other Skincare" # Default category

def parse_skin_concerns(text):
    if not text: return []
    # Normalize separators: replace ' & ' and ' / ' with ','
    text = text.replace(' & ', ', ').replace(' / ', ', ')
    # Split by comma, handling optional spaces around the comma
    concerns = re.split(r'\s*,\s*', text)
    return [concern.strip() for concern in concerns if concern.strip()]

def infer_key_ingredients(name, skin_concerns_text=""):
    # Combine name and skin concerns for a broader search base
    name_lower = name.lower() + " " + skin_concerns_text.lower()
    ingredients = set()

    # Add ingredients based on keywords found in the combined text
    # This list can be expanded based on common Minimalist product ingredients
    if "salicylic acid" in name_lower: ingredients.add("Salicylic Acid")
    if "lha" in name_lower: ingredients.add("LHA")
    if "vitamin c" in name_lower or "ascorbic acid" in name_lower: ingredients.add("Vitamin C")
    if "niacinamide" in name_lower: ingredients.add("Niacinamide")
    if "vitamin b5" in name_lower or "panthenol" in name_lower: ingredients.add("Vitamin B5 (Panthenol)")
    if "alpha arbutin" in name_lower: ingredients.add("Alpha Arbutin")
    if "pha" in name_lower or "polyhydroxy acid" in name_lower: ingredients.add("PHA (Polyhydroxy Acid)")
    if "retinol" in name_lower: ingredients.add("Retinol")
    if "retinal" in name_lower: ingredients.add("Retinal")
    if "granactive retinoid" in name_lower: ingredients.add("Granactive Retinoid")
    if "aha" in name_lower: ingredients.add("AHA") # Generic AHA
    if "bha" in name_lower: ingredients.add("BHA") # Generic BHA
    if "glycolic acid" in name_lower: ingredients.add("Glycolic Acid")
    if "hyaluronic acid" in name_lower: ingredients.add("Hyaluronic Acid")
    if "pga" in name_lower or "polyglutamic acid" in name_lower: ingredients.add("PGA (Polyglutamic Acid)")
    if "tranexamic acid" in name_lower: ingredients.add("Tranexamic Acid")
    if "oat extract" in name_lower or "oat" in name_lower: ingredients.add("Oat Extract")
    if "vitamin k" in name_lower: ingredients.add("Vitamin K")
    if "alpha lipoic acid" in name_lower: ingredients.add("Alpha Lipoic Acid")
    if "marula oil" in name_lower: ingredients.add("Marula Oil")
    if "peptides" in name_lower or "peptide" in name_lower: ingredients.add("Peptides")
    if "zinc" in name_lower: ingredients.add("Zinc")
    if "ferulic" in name_lower or "ferulic acid" in name_lower: ingredients.add("Ferulic Acid")
    if "vitamin e" in name_lower or "tocopherol" in name_lower: ingredients.add("Vitamin E")
    if "squalane" in name_lower: ingredients.add("Squalane")
    if "ceramide" in name_lower: ingredients.add("Ceramides")
    if "maleic" in name_lower: ingredients.add("Maleic Bond Repair Complex") # For hair products
    if "capixyl" in name_lower: ingredients.add("Capixyl")
    if "redensyl" in name_lower: ingredients.add("Redensyl")
    if "procapil" in name_lower: ingredients.add("Procapil")
    if "biotin" in name_lower: ingredients.add("Biotin")
    if "amino acid" in name_lower: ingredients.add("Amino Acids")
    if "rosehip oil" in name_lower: ingredients.add("Rosehip Oil")
    if "bakuchiol" in name_lower: ingredients.add("Bakuchiol")
    if "centella" in name_lower or "cica" in name_lower: ingredients.add("Centella Asiatica (Cica)")
    if "aquaporin" in name_lower: ingredients.add("Aquaporin Booster")
    if "silymarin" in name_lower: ingredients.add("Silymarin") # For some sunscreens
    if "nonapeptide" in name_lower: ingredients.add("Nonapeptide") # For underarm roll-on
    if "mandelic acid" in name_lower: ingredients.add("Mandelic Acid")
    if "azelaic acid" in name_lower: ingredients.add("Azelaic Acid")
    if "kojic acid" in name_lower: ingredients.add("Kojic Acid")
    if "beta glucan" in name_lower: ingredients.add("Beta Glucan")
    if "propolis" in name_lower: ingredients.add("Propolis")

    return list(ingredients) if ingredients else []

def generate_description(name, skin_concerns_list):
    if not skin_concerns_list:
        return f"{name} is a high-quality product from Minimalist designed for your specific concerns."

    # Create a more natural sentence for skin concerns
    if len(skin_concerns_list) == 1:
        concerns_string = skin_concerns_list[0].lower()
    elif len(skin_concerns_list) == 2:
        concerns_string = f"{skin_concerns_list[0].lower()} and {skin_concerns_list[1].lower()}"
    else:
        # For three or more, use "A, B, and C"
        concerns_string = ", ".join(c.lower() for c in skin_concerns_list[:-1]) + f", and {skin_concerns_list[-1].lower()}"

    description = f"Targets {concerns_string}."

    # Add a category-specific sentence for more context
    category = infer_category(name)
    if category == "Cleanser" or category == "Face Wash":
        description += " This cleanser gently purifies the skin, removing impurities and preparing it for subsequent treatments."
    elif category == "Serum":
        description += " This potent serum delivers concentrated ingredients to address specific skin issues effectively."
    elif category == "Moisturizer" or category == "Face Cream" or category == "Cream":
        description += " Formulated to hydrate, nourish, and protect the skin's barrier."
    elif category == "Sunscreen" or category == "Sunscreen Stick":
        description += " Provides essential broad-spectrum protection against harmful UV rays."
    elif category == "Toner":
        description += " Helps to balance the skin's pH, refine pores, and enhance absorption of other products."
    elif category == "Peel" or category == "Exfoliator":
        description += " An exfoliating treatment to remove dead skin cells, revealing brighter and smoother skin."
    elif category == "Hair Serum":
        description += " Designed to address specific hair concerns like growth, damage, or frizz."
    elif category == "Lip Balm":
        description += " A treatment to nourish, hydrate, and protect the lips."
    elif category == "Eye Cream":
        description += " Specifically formulated for the delicate eye area to target concerns like dark circles or fine lines."
    else:
        description += f" An effective Minimalist solution for your skincare or haircare needs."
    return description.strip()

def extract_products_from_markdown(markdown_content):
    products = []
    # Revised regex pattern to handle the complex image block and overall structure
    product_pattern = re.compile(
        r"\["  # Start of the main link for the image block
        r"(?P<image_block_content>"  # Capture group for the content inside the main link's text part
            r"!\[(?P<img_alt1>[^\]]*?)\]\((?P<img_url_raw>[^)]+?)\)"  # The first ![alt](url)
            r"(?:!\[[^\]]*?\]\([^)]+?\))*"  # Zero or more subsequent ![alt](url)s (non-capturing group for repetition)
        r")"  # End of image_block_content
        r"\]\((?P<product_link_wrapper_url>[^)]+?)\)"  # Closing part of the main image link ](URL)
        r"\s*\n+\s*"  # Separator: one or more newlines, with optional surrounding spaces
        r"\[(?P<product_name>[^\]]+?)\]\((?P<product_url>[^)]+?)(?:\s*\"[^\"]*?\")?\)"  # Product name link: [Name](URL "OptionalTitle")
        r"\s*\n+\s*"  # Separator
        r"(?P<skin_concerns_text>[^₹\n][^\n]*?(?:\s*\n+[ \t]*[A-Za-z0-9,&/\s]+[^₹\n])?)" # Skin concerns line: not starting with ₹, non-empty, non-greedy,
                                                                                          # and optionally allow it to span a second line if that line also doesn't start with price
                                                                                          # and contains typical concern characters.
        r"(?=\s*\n+\s*(?:₹|Select Size|Select Title|Add to Cart|\[!\[|\Z))",  # Positive lookahead for terminators
        re.IGNORECASE | re.DOTALL # IGNORECASE for alt text/names, DOTALL for . to match newlines if any part of image_block_content spans lines
    )

    print(f"DEBUG: Starting regex search on markdown content (length: {len(markdown_content)}).")
    match_count = 0
    for match in product_pattern.finditer(markdown_content):
        match_count += 1
        # print(f"\nDEBUG: Found potential match #{match_count}. Full match block:\n{match.group(0)}") # Potentially very long

        raw_name = match.group("product_name").strip()
        # img_alt1 = match.group("img_alt1").strip() # Alt text of the first image
        raw_img_url = match.group("img_url_raw").strip() # URL of the first image
        product_url = match.group("product_url").strip()
        skin_concerns_text = match.group("skin_concerns_text").strip().replace('\n', ' ') # Join multi-line concerns

        # print(f"DEBUG #{match_count}: Raw Name: '{raw_name}'")
        # print(f"DEBUG #{match_count}: Raw Img URL: '{raw_img_url}'")
        # print(f"DEBUG #{match_count}: Product URL: '{product_url}'")
        # print(f"DEBUG #{match_count}: Skin Concerns Text (raw): '{match.group('skin_concerns_text')}' -> Cleaned: '{skin_concerns_text}'")

        name = " ".join(raw_name.split()) # Normalize whitespace
        if not product_url.startswith("http"): # Ensure product_url is absolute
            product_url = "https://beminimalist.co" + product_url

        image_url = clean_image_url(raw_img_url)
        category = infer_category(name)
        skin_concerns_list = parse_skin_concerns(skin_concerns_text)
        key_ingredients_list = infer_key_ingredients(name, skin_concerns_text)
        description = generate_description(name, skin_concerns_list)

        if not name or not image_url or not product_url:
            print(f"DEBUG #{match_count}: Skipping a match due to missing critical info: Name='{name}', ImgURL='{image_url}', ProdURL='{product_url}'")
            continue

        product_data = {
            "name": name,
            "description": description,
            "image_url": image_url,
            "product_url": product_url,
            "category": category,
            "skin_concerns": skin_concerns_list,
            "key_ingredients": key_ingredients_list
        }
        # print(f"DEBUG #{match_count}: Processed product_data: {product_data}")
        products.append(product_data)

    if match_count == 0:
        print("DEBUG: No matches found by the regex pattern. Ensure the markdown structure aligns with the regex.")
    else:
        print(f"\nDEBUG: Total matches processed: {match_count}")

    return products

# --- Main script execution ---
try:
    file_path = 'minimalist_all_products.json'
    print(f"DEBUG: Attempting to read file: {file_path}")
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            parsed_json_data = json.load(f)
        print(f"DEBUG: Successfully loaded and parsed JSON from {file_path}.")
    except FileNotFoundError:
        print(f"ERROR: File not found: {file_path}. Please ensure it's uploaded to Colab session storage.")
        parsed_json_data = {}
    except json.JSONDecodeError as e:
        print(f"ERROR: Error decoding JSON from file: {file_path}. Details: {e}")
        try:
            with open(file_path, 'r', encoding='utf-8') as f_text:
                print(f"DEBUG: Raw file content (first 500 chars for JSON error inspection):\n{f_text.read(500)}")
        except Exception as read_err:
            print(f"DEBUG: Could not read raw file content after JSON error: {read_err}")
        parsed_json_data = {}

    markdown_text_content = parsed_json_data.get("markdown", "")

    if not markdown_text_content:
        print("ERROR: Markdown content is empty or not found under the 'markdown' key in the JSON file.")
        print(json.dumps({"error": "Markdown content not found or empty.", "products": []}))
    else:
        print(f"DEBUG: Length of markdown content: {len(markdown_text_content)}")
        # For brevity in logs, only print a small snippet if it's very long
        # if len(markdown_text_content) > 1000:
        #     print(f"DEBUG: Markdown content (first 500 chars):\n{markdown_text_content[:500]}\n...")
        # else:
        #     print(f"DEBUG: Markdown content:\n{markdown_text_content}")

        extracted_products = extract_products_from_markdown(markdown_text_content)

        if not extracted_products:
            print("WARNING: No products were extracted. The final list is empty. Check DEBUG messages above for regex issues or inspect the markdown structure against the regex.")
        else:
            # 1. To extract the number of products by counting "name"
            #    (More accurately, count the number of product dictionaries in the list)
            number_of_products = len(extracted_products)
            print(f"SUCCESS: Extracted {number_of_products} products.")

            # 2. Save this output file as entries_supabase.json
            output_file_name = "entries_supabase.json"
            with open(output_file_name, 'w', encoding='utf-8') as f_out:
                json.dump(extracted_products, f_out, indent=2, ensure_ascii=False)
            print(f"SUCCESS: Product data saved to {output_file_name}")


        print("\n--- FINAL OUTPUT (also saved to entries_supabase.json if products were found) ---")
        print(json.dumps(extracted_products, indent=2))

except Exception as e:
    print(f"CRITICAL ERROR: An unexpected error occurred in the main script: {e}")
    import traceback
    traceback.print_exc()
    print(json.dumps({"error": f"Critical script error: {str(e)}", "products": []}))